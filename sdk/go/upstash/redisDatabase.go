// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package upstash

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ## Example Usage
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// 	"github.com/upstash/upstash-pulumi-provider/sdk/go/upstash"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		_, err := upstash.NewRedisDatabase(ctx, "exampleDB", &upstash.RedisDatabaseArgs{
// 			DatabaseName: pulumi.String("Terraform DB6"),
// 			Multizone:    pulumi.Bool(true),
// 			Region:       pulumi.String("eu-west-1"),
// 			Tls:          pulumi.Bool(true),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
type RedisDatabase struct {
	pulumi.CustomResourceState

	// When enabled, all writes are synchronously persisted to the disk.
	//
	// Deprecated: Consistent option is deprecated.
	Consistent pulumi.BoolPtrOutput `pulumi:"consistent"`
	// Creation time of the database
	CreationTime pulumi.IntOutput `pulumi:"creationTime"`
	// Unique Database ID for created database
	DatabaseId pulumi.StringOutput `pulumi:"databaseId"`
	// Name of the database
	DatabaseName pulumi.StringOutput `pulumi:"databaseName"`
	// Type of the database
	DatabaseType pulumi.StringOutput `pulumi:"databaseType"`
	// Daily bandwidth limit for the database
	DbDailyBandwidthLimit pulumi.IntOutput `pulumi:"dbDailyBandwidthLimit"`
	// Disk threshold for the database
	DbDiskThreshold pulumi.IntOutput `pulumi:"dbDiskThreshold"`
	// Max clients for the database
	DbMaxClients pulumi.IntOutput `pulumi:"dbMaxClients"`
	// Max commands per second for the database
	DbMaxCommandsPerSecond pulumi.IntOutput `pulumi:"dbMaxCommandsPerSecond"`
	// Max entry size for the database
	DbMaxEntrySize pulumi.IntOutput `pulumi:"dbMaxEntrySize"`
	// Max request size for the database
	DbMaxRequestSize pulumi.IntOutput `pulumi:"dbMaxRequestSize"`
	// Memory threshold for the database
	DbMemoryThreshold pulumi.IntOutput `pulumi:"dbMemoryThreshold"`
	// Database URL for connection
	Endpoint pulumi.StringOutput `pulumi:"endpoint"`
	// When enabled, database becomes highly available and is deployed in multiple zones. (If changed to false from true,
	// results in deletion and recreation of the resource)
	Multizone pulumi.BoolPtrOutput `pulumi:"multizone"`
	// Password of the database
	Password pulumi.StringOutput `pulumi:"password"`
	// Port of the endpoint
	Port pulumi.IntOutput `pulumi:"port"`
	// Rest Token for the database.
	ReadOnlyRestToken pulumi.StringOutput `pulumi:"readOnlyRestToken"`
	// region of the database. Possible values are: "global", "eu-west-1", "us-east-1", "us-west-1", "ap-northeast-1" ,
	// "eu-central1"
	Region pulumi.StringOutput `pulumi:"region"`
	// Rest Token for the database.
	RestToken pulumi.StringOutput `pulumi:"restToken"`
	// State of the database
	State pulumi.StringOutput `pulumi:"state"`
	// When enabled, data is encrypted in transit. (If changed to false from true, results in deletion and recreation of the
	// resource)
	//
	// Deprecated: TLS option is deprecated. TLS will always be enabled. If you have a DB without tls enabled, run the same configuration with tls=true to enable it.
	Tls pulumi.BoolOutput `pulumi:"tls"`
	// User email for the database
	UserEmail pulumi.StringOutput `pulumi:"userEmail"`
}

// NewRedisDatabase registers a new resource with the given unique name, arguments, and options.
func NewRedisDatabase(ctx *pulumi.Context,
	name string, args *RedisDatabaseArgs, opts ...pulumi.ResourceOption) (*RedisDatabase, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.DatabaseName == nil {
		return nil, errors.New("invalid value for required argument 'DatabaseName'")
	}
	if args.Region == nil {
		return nil, errors.New("invalid value for required argument 'Region'")
	}
	secrets := pulumi.AdditionalSecretOutputs([]string{
		"password",
	})
	opts = append(opts, secrets)
	opts = pkgResourceDefaultOpts(opts)
	var resource RedisDatabase
	err := ctx.RegisterResource("upstash:index/redisDatabase:RedisDatabase", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetRedisDatabase gets an existing RedisDatabase resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetRedisDatabase(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *RedisDatabaseState, opts ...pulumi.ResourceOption) (*RedisDatabase, error) {
	var resource RedisDatabase
	err := ctx.ReadResource("upstash:index/redisDatabase:RedisDatabase", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering RedisDatabase resources.
type redisDatabaseState struct {
	// When enabled, all writes are synchronously persisted to the disk.
	//
	// Deprecated: Consistent option is deprecated.
	Consistent *bool `pulumi:"consistent"`
	// Creation time of the database
	CreationTime *int `pulumi:"creationTime"`
	// Unique Database ID for created database
	DatabaseId *string `pulumi:"databaseId"`
	// Name of the database
	DatabaseName *string `pulumi:"databaseName"`
	// Type of the database
	DatabaseType *string `pulumi:"databaseType"`
	// Daily bandwidth limit for the database
	DbDailyBandwidthLimit *int `pulumi:"dbDailyBandwidthLimit"`
	// Disk threshold for the database
	DbDiskThreshold *int `pulumi:"dbDiskThreshold"`
	// Max clients for the database
	DbMaxClients *int `pulumi:"dbMaxClients"`
	// Max commands per second for the database
	DbMaxCommandsPerSecond *int `pulumi:"dbMaxCommandsPerSecond"`
	// Max entry size for the database
	DbMaxEntrySize *int `pulumi:"dbMaxEntrySize"`
	// Max request size for the database
	DbMaxRequestSize *int `pulumi:"dbMaxRequestSize"`
	// Memory threshold for the database
	DbMemoryThreshold *int `pulumi:"dbMemoryThreshold"`
	// Database URL for connection
	Endpoint *string `pulumi:"endpoint"`
	// When enabled, database becomes highly available and is deployed in multiple zones. (If changed to false from true,
	// results in deletion and recreation of the resource)
	Multizone *bool `pulumi:"multizone"`
	// Password of the database
	Password *string `pulumi:"password"`
	// Port of the endpoint
	Port *int `pulumi:"port"`
	// Rest Token for the database.
	ReadOnlyRestToken *string `pulumi:"readOnlyRestToken"`
	// region of the database. Possible values are: "global", "eu-west-1", "us-east-1", "us-west-1", "ap-northeast-1" ,
	// "eu-central1"
	Region *string `pulumi:"region"`
	// Rest Token for the database.
	RestToken *string `pulumi:"restToken"`
	// State of the database
	State *string `pulumi:"state"`
	// When enabled, data is encrypted in transit. (If changed to false from true, results in deletion and recreation of the
	// resource)
	//
	// Deprecated: TLS option is deprecated. TLS will always be enabled. If you have a DB without tls enabled, run the same configuration with tls=true to enable it.
	Tls *bool `pulumi:"tls"`
	// User email for the database
	UserEmail *string `pulumi:"userEmail"`
}

type RedisDatabaseState struct {
	// When enabled, all writes are synchronously persisted to the disk.
	//
	// Deprecated: Consistent option is deprecated.
	Consistent pulumi.BoolPtrInput
	// Creation time of the database
	CreationTime pulumi.IntPtrInput
	// Unique Database ID for created database
	DatabaseId pulumi.StringPtrInput
	// Name of the database
	DatabaseName pulumi.StringPtrInput
	// Type of the database
	DatabaseType pulumi.StringPtrInput
	// Daily bandwidth limit for the database
	DbDailyBandwidthLimit pulumi.IntPtrInput
	// Disk threshold for the database
	DbDiskThreshold pulumi.IntPtrInput
	// Max clients for the database
	DbMaxClients pulumi.IntPtrInput
	// Max commands per second for the database
	DbMaxCommandsPerSecond pulumi.IntPtrInput
	// Max entry size for the database
	DbMaxEntrySize pulumi.IntPtrInput
	// Max request size for the database
	DbMaxRequestSize pulumi.IntPtrInput
	// Memory threshold for the database
	DbMemoryThreshold pulumi.IntPtrInput
	// Database URL for connection
	Endpoint pulumi.StringPtrInput
	// When enabled, database becomes highly available and is deployed in multiple zones. (If changed to false from true,
	// results in deletion and recreation of the resource)
	Multizone pulumi.BoolPtrInput
	// Password of the database
	Password pulumi.StringPtrInput
	// Port of the endpoint
	Port pulumi.IntPtrInput
	// Rest Token for the database.
	ReadOnlyRestToken pulumi.StringPtrInput
	// region of the database. Possible values are: "global", "eu-west-1", "us-east-1", "us-west-1", "ap-northeast-1" ,
	// "eu-central1"
	Region pulumi.StringPtrInput
	// Rest Token for the database.
	RestToken pulumi.StringPtrInput
	// State of the database
	State pulumi.StringPtrInput
	// When enabled, data is encrypted in transit. (If changed to false from true, results in deletion and recreation of the
	// resource)
	//
	// Deprecated: TLS option is deprecated. TLS will always be enabled. If you have a DB without tls enabled, run the same configuration with tls=true to enable it.
	Tls pulumi.BoolPtrInput
	// User email for the database
	UserEmail pulumi.StringPtrInput
}

func (RedisDatabaseState) ElementType() reflect.Type {
	return reflect.TypeOf((*redisDatabaseState)(nil)).Elem()
}

type redisDatabaseArgs struct {
	// When enabled, all writes are synchronously persisted to the disk.
	//
	// Deprecated: Consistent option is deprecated.
	Consistent *bool `pulumi:"consistent"`
	// Name of the database
	DatabaseName string `pulumi:"databaseName"`
	// When enabled, database becomes highly available and is deployed in multiple zones. (If changed to false from true,
	// results in deletion and recreation of the resource)
	Multizone *bool `pulumi:"multizone"`
	// region of the database. Possible values are: "global", "eu-west-1", "us-east-1", "us-west-1", "ap-northeast-1" ,
	// "eu-central1"
	Region string `pulumi:"region"`
	// When enabled, data is encrypted in transit. (If changed to false from true, results in deletion and recreation of the
	// resource)
	//
	// Deprecated: TLS option is deprecated. TLS will always be enabled. If you have a DB without tls enabled, run the same configuration with tls=true to enable it.
	Tls *bool `pulumi:"tls"`
}

// The set of arguments for constructing a RedisDatabase resource.
type RedisDatabaseArgs struct {
	// When enabled, all writes are synchronously persisted to the disk.
	//
	// Deprecated: Consistent option is deprecated.
	Consistent pulumi.BoolPtrInput
	// Name of the database
	DatabaseName pulumi.StringInput
	// When enabled, database becomes highly available and is deployed in multiple zones. (If changed to false from true,
	// results in deletion and recreation of the resource)
	Multizone pulumi.BoolPtrInput
	// region of the database. Possible values are: "global", "eu-west-1", "us-east-1", "us-west-1", "ap-northeast-1" ,
	// "eu-central1"
	Region pulumi.StringInput
	// When enabled, data is encrypted in transit. (If changed to false from true, results in deletion and recreation of the
	// resource)
	//
	// Deprecated: TLS option is deprecated. TLS will always be enabled. If you have a DB without tls enabled, run the same configuration with tls=true to enable it.
	Tls pulumi.BoolPtrInput
}

func (RedisDatabaseArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*redisDatabaseArgs)(nil)).Elem()
}

type RedisDatabaseInput interface {
	pulumi.Input

	ToRedisDatabaseOutput() RedisDatabaseOutput
	ToRedisDatabaseOutputWithContext(ctx context.Context) RedisDatabaseOutput
}

func (*RedisDatabase) ElementType() reflect.Type {
	return reflect.TypeOf((**RedisDatabase)(nil)).Elem()
}

func (i *RedisDatabase) ToRedisDatabaseOutput() RedisDatabaseOutput {
	return i.ToRedisDatabaseOutputWithContext(context.Background())
}

func (i *RedisDatabase) ToRedisDatabaseOutputWithContext(ctx context.Context) RedisDatabaseOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RedisDatabaseOutput)
}

// RedisDatabaseArrayInput is an input type that accepts RedisDatabaseArray and RedisDatabaseArrayOutput values.
// You can construct a concrete instance of `RedisDatabaseArrayInput` via:
//
//          RedisDatabaseArray{ RedisDatabaseArgs{...} }
type RedisDatabaseArrayInput interface {
	pulumi.Input

	ToRedisDatabaseArrayOutput() RedisDatabaseArrayOutput
	ToRedisDatabaseArrayOutputWithContext(context.Context) RedisDatabaseArrayOutput
}

type RedisDatabaseArray []RedisDatabaseInput

func (RedisDatabaseArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*RedisDatabase)(nil)).Elem()
}

func (i RedisDatabaseArray) ToRedisDatabaseArrayOutput() RedisDatabaseArrayOutput {
	return i.ToRedisDatabaseArrayOutputWithContext(context.Background())
}

func (i RedisDatabaseArray) ToRedisDatabaseArrayOutputWithContext(ctx context.Context) RedisDatabaseArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RedisDatabaseArrayOutput)
}

// RedisDatabaseMapInput is an input type that accepts RedisDatabaseMap and RedisDatabaseMapOutput values.
// You can construct a concrete instance of `RedisDatabaseMapInput` via:
//
//          RedisDatabaseMap{ "key": RedisDatabaseArgs{...} }
type RedisDatabaseMapInput interface {
	pulumi.Input

	ToRedisDatabaseMapOutput() RedisDatabaseMapOutput
	ToRedisDatabaseMapOutputWithContext(context.Context) RedisDatabaseMapOutput
}

type RedisDatabaseMap map[string]RedisDatabaseInput

func (RedisDatabaseMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*RedisDatabase)(nil)).Elem()
}

func (i RedisDatabaseMap) ToRedisDatabaseMapOutput() RedisDatabaseMapOutput {
	return i.ToRedisDatabaseMapOutputWithContext(context.Background())
}

func (i RedisDatabaseMap) ToRedisDatabaseMapOutputWithContext(ctx context.Context) RedisDatabaseMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RedisDatabaseMapOutput)
}

type RedisDatabaseOutput struct{ *pulumi.OutputState }

func (RedisDatabaseOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RedisDatabase)(nil)).Elem()
}

func (o RedisDatabaseOutput) ToRedisDatabaseOutput() RedisDatabaseOutput {
	return o
}

func (o RedisDatabaseOutput) ToRedisDatabaseOutputWithContext(ctx context.Context) RedisDatabaseOutput {
	return o
}

// When enabled, all writes are synchronously persisted to the disk.
//
// Deprecated: Consistent option is deprecated.
func (o RedisDatabaseOutput) Consistent() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *RedisDatabase) pulumi.BoolPtrOutput { return v.Consistent }).(pulumi.BoolPtrOutput)
}

// Creation time of the database
func (o RedisDatabaseOutput) CreationTime() pulumi.IntOutput {
	return o.ApplyT(func(v *RedisDatabase) pulumi.IntOutput { return v.CreationTime }).(pulumi.IntOutput)
}

// Unique Database ID for created database
func (o RedisDatabaseOutput) DatabaseId() pulumi.StringOutput {
	return o.ApplyT(func(v *RedisDatabase) pulumi.StringOutput { return v.DatabaseId }).(pulumi.StringOutput)
}

// Name of the database
func (o RedisDatabaseOutput) DatabaseName() pulumi.StringOutput {
	return o.ApplyT(func(v *RedisDatabase) pulumi.StringOutput { return v.DatabaseName }).(pulumi.StringOutput)
}

// Type of the database
func (o RedisDatabaseOutput) DatabaseType() pulumi.StringOutput {
	return o.ApplyT(func(v *RedisDatabase) pulumi.StringOutput { return v.DatabaseType }).(pulumi.StringOutput)
}

// Daily bandwidth limit for the database
func (o RedisDatabaseOutput) DbDailyBandwidthLimit() pulumi.IntOutput {
	return o.ApplyT(func(v *RedisDatabase) pulumi.IntOutput { return v.DbDailyBandwidthLimit }).(pulumi.IntOutput)
}

// Disk threshold for the database
func (o RedisDatabaseOutput) DbDiskThreshold() pulumi.IntOutput {
	return o.ApplyT(func(v *RedisDatabase) pulumi.IntOutput { return v.DbDiskThreshold }).(pulumi.IntOutput)
}

// Max clients for the database
func (o RedisDatabaseOutput) DbMaxClients() pulumi.IntOutput {
	return o.ApplyT(func(v *RedisDatabase) pulumi.IntOutput { return v.DbMaxClients }).(pulumi.IntOutput)
}

// Max commands per second for the database
func (o RedisDatabaseOutput) DbMaxCommandsPerSecond() pulumi.IntOutput {
	return o.ApplyT(func(v *RedisDatabase) pulumi.IntOutput { return v.DbMaxCommandsPerSecond }).(pulumi.IntOutput)
}

// Max entry size for the database
func (o RedisDatabaseOutput) DbMaxEntrySize() pulumi.IntOutput {
	return o.ApplyT(func(v *RedisDatabase) pulumi.IntOutput { return v.DbMaxEntrySize }).(pulumi.IntOutput)
}

// Max request size for the database
func (o RedisDatabaseOutput) DbMaxRequestSize() pulumi.IntOutput {
	return o.ApplyT(func(v *RedisDatabase) pulumi.IntOutput { return v.DbMaxRequestSize }).(pulumi.IntOutput)
}

// Memory threshold for the database
func (o RedisDatabaseOutput) DbMemoryThreshold() pulumi.IntOutput {
	return o.ApplyT(func(v *RedisDatabase) pulumi.IntOutput { return v.DbMemoryThreshold }).(pulumi.IntOutput)
}

// Database URL for connection
func (o RedisDatabaseOutput) Endpoint() pulumi.StringOutput {
	return o.ApplyT(func(v *RedisDatabase) pulumi.StringOutput { return v.Endpoint }).(pulumi.StringOutput)
}

// When enabled, database becomes highly available and is deployed in multiple zones. (If changed to false from true,
// results in deletion and recreation of the resource)
func (o RedisDatabaseOutput) Multizone() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *RedisDatabase) pulumi.BoolPtrOutput { return v.Multizone }).(pulumi.BoolPtrOutput)
}

// Password of the database
func (o RedisDatabaseOutput) Password() pulumi.StringOutput {
	return o.ApplyT(func(v *RedisDatabase) pulumi.StringOutput { return v.Password }).(pulumi.StringOutput)
}

// Port of the endpoint
func (o RedisDatabaseOutput) Port() pulumi.IntOutput {
	return o.ApplyT(func(v *RedisDatabase) pulumi.IntOutput { return v.Port }).(pulumi.IntOutput)
}

// Rest Token for the database.
func (o RedisDatabaseOutput) ReadOnlyRestToken() pulumi.StringOutput {
	return o.ApplyT(func(v *RedisDatabase) pulumi.StringOutput { return v.ReadOnlyRestToken }).(pulumi.StringOutput)
}

// region of the database. Possible values are: "global", "eu-west-1", "us-east-1", "us-west-1", "ap-northeast-1" ,
// "eu-central1"
func (o RedisDatabaseOutput) Region() pulumi.StringOutput {
	return o.ApplyT(func(v *RedisDatabase) pulumi.StringOutput { return v.Region }).(pulumi.StringOutput)
}

// Rest Token for the database.
func (o RedisDatabaseOutput) RestToken() pulumi.StringOutput {
	return o.ApplyT(func(v *RedisDatabase) pulumi.StringOutput { return v.RestToken }).(pulumi.StringOutput)
}

// State of the database
func (o RedisDatabaseOutput) State() pulumi.StringOutput {
	return o.ApplyT(func(v *RedisDatabase) pulumi.StringOutput { return v.State }).(pulumi.StringOutput)
}

// When enabled, data is encrypted in transit. (If changed to false from true, results in deletion and recreation of the
// resource)
//
// Deprecated: TLS option is deprecated. TLS will always be enabled. If you have a DB without tls enabled, run the same configuration with tls=true to enable it.
func (o RedisDatabaseOutput) Tls() pulumi.BoolOutput {
	return o.ApplyT(func(v *RedisDatabase) pulumi.BoolOutput { return v.Tls }).(pulumi.BoolOutput)
}

// User email for the database
func (o RedisDatabaseOutput) UserEmail() pulumi.StringOutput {
	return o.ApplyT(func(v *RedisDatabase) pulumi.StringOutput { return v.UserEmail }).(pulumi.StringOutput)
}

type RedisDatabaseArrayOutput struct{ *pulumi.OutputState }

func (RedisDatabaseArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*RedisDatabase)(nil)).Elem()
}

func (o RedisDatabaseArrayOutput) ToRedisDatabaseArrayOutput() RedisDatabaseArrayOutput {
	return o
}

func (o RedisDatabaseArrayOutput) ToRedisDatabaseArrayOutputWithContext(ctx context.Context) RedisDatabaseArrayOutput {
	return o
}

func (o RedisDatabaseArrayOutput) Index(i pulumi.IntInput) RedisDatabaseOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *RedisDatabase {
		return vs[0].([]*RedisDatabase)[vs[1].(int)]
	}).(RedisDatabaseOutput)
}

type RedisDatabaseMapOutput struct{ *pulumi.OutputState }

func (RedisDatabaseMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*RedisDatabase)(nil)).Elem()
}

func (o RedisDatabaseMapOutput) ToRedisDatabaseMapOutput() RedisDatabaseMapOutput {
	return o
}

func (o RedisDatabaseMapOutput) ToRedisDatabaseMapOutputWithContext(ctx context.Context) RedisDatabaseMapOutput {
	return o
}

func (o RedisDatabaseMapOutput) MapIndex(k pulumi.StringInput) RedisDatabaseOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *RedisDatabase {
		return vs[0].(map[string]*RedisDatabase)[vs[1].(string)]
	}).(RedisDatabaseOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*RedisDatabaseInput)(nil)).Elem(), &RedisDatabase{})
	pulumi.RegisterInputType(reflect.TypeOf((*RedisDatabaseArrayInput)(nil)).Elem(), RedisDatabaseArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RedisDatabaseMapInput)(nil)).Elem(), RedisDatabaseMap{})
	pulumi.RegisterOutputType(RedisDatabaseOutput{})
	pulumi.RegisterOutputType(RedisDatabaseArrayOutput{})
	pulumi.RegisterOutputType(RedisDatabaseMapOutput{})
}
